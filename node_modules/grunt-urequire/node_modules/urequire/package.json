{
  "name": "urequire",
  "description": "Javascript Module converter: write modular code once, convert to UMD and run/test on AMD (browser/requirejs) & nodejs.",
  "version": "0.3.0beta1",
  "homepage": "https://github.com/anodynos/urequire",
  "author": {
    "name": "Agelos Pikoulas",
    "email": "agelos.pikoulas@gmail.com"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "keywords": [
    "modules",
    "module",
    "modular",
    "format",
    "convert",
    "converter",
    "conversion",
    "commonjs",
    "AMD",
    "UMD",
    "UMDjs",
    "requirejs",
    "require",
    "define",
    "umdify",
    "nodefy",
    "browserify",
    "dependency",
    "dependencies",
    "bundle",
    "package"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/anodynos/urequire"
  },
  "bin": {
    "urequire": "./build/code/urequireCmd.js"
  },
  "main": "./build/code/urequire.js",
  "test": "mocha build/spec --recursive --bail --reporter spec",
  "directories": {
    "doc": "./doc",
    "dist": "./build"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "lodash": "*",
    "underscore.string": "*",
    "uberscore": "0.0.8",
    "commander": "1.1.x",
    "wrench": "1.4.x",
    "uglify-js": "1.3.x",
    "requirejs": "~2.1.0",
    "almond": "0.2.5",
    "butter-require": "0.0.x",
    "coffee-script": "~1.6.2",
    "YouAreDaChef": "*"
  },
  "devDependencies": {
    "chai": "*",
    "grunt": "0.3.x",
    "grunt-shell": "0.1.x",
    "grunt-contrib": "~0.3"
  },
  "readme": "# uRequire v0.3.0beta\n\n**Write *modular Javascript code* once, run everywhere** using [UMD](https://github.com/umdjs/umd) based module translation/conversion that targets Web [(AMD/RequireJS)](http://requirejs.org/) & nodejs/commonjs module systems.\n\n___________________________________________________________________________\n## Breaking news for v0.3.0 beta\n\nThis documentation is from older versions v0.1.x / 0.2.x.\n\n_Skip below, if you're after general information._\n\nEverything mentioned here works the same, but current version 0.3 (currently in beta) brings many great features, NOT yet documented :\n\n### Universal **Combined** Module optimization for Web, AMD & nodejs!\n\nThe most important feature, a new `combined` template, that builds (optimizes with `r.js` & `almond`) and outputs a single .js file, thats a 3-fold build: Web/Script, Web/AMD & nodejs.\n\nIn all cases, globals/externals dont have to be inlined, but can be used either from `window`, the *AMD config* or *nodejs `require`* respectively.\nThe `combined` script automagically *detects at runtime where it is excuting* and chooses appropriatelly.\n\nIn more detail:\n\n#### Web/Script </script>\n\nWorks in browser, as a simple `<script/>`, independently of AMD/RequireJS.\nThe script can register some global (`window`) variables when it loads, for example `$2` or `_B`, via the `rootExports` declaration.\nIt accesses all other (non-included) global dependencies through the global space (`window`), like all plain `<script/>` do.\nSo for example, you load your 'jquery.js', 'lodash.js', 'Backbone.js' and then you load your 'MyApp.js' and you're done!\n\n#### Web/AMD\n\nWorks as an AMD dependency, loading all other (non-included) dependencies through AMD's mechanism.\nIn other words its using `rjs.baseUrl`, `rjs.paths`, `rjs.shim` etc.\n\n#### nodejs\n\nWorks in nodejs, as is. Its loading all (non-included) dependencies through nodejs's 'require'.\nIt has no other dependencies, i.e you dont need to have *uRequire* or *RequireJs* installed locally at all.\n\nAre you still concatenating files ? uRequire your project now!\n\n###  **bundleExports**, a dependencies-injection mechanism:\n\nA sexy new feature, `dependencies.bundleExports` allows you to declare bundle-wide *global* dependencies. These are implicitely available in all your modules, without repeating the `require`s.\n\nFor example, if you use ['lodash', 'backbone', 'myLib', ...] in all your bundle modules, just use a `dependencies.bundleExports: ['lodash', 'backbone', 'myLib']` and its saving you from having to require 'em in **every module of your bundle**.\n\nIf you want to have precise control over the variables that hold you modules, use this format:\n\n    dependencies.bundleExports: {\n        'lodash': '_',\n        'backbone': 'Backbone',\n        'myLib': ['myLib', 'myLibOtherName']\n       }\n\nMost times, uRequire can discover the variable names, if its 'define'd even once in an AMD module!\n\n### **uRequire config** A completely new 'bundle' & 'build' hierarchical configuration scheme.\n\nThe 'derive' feature ('config' action in urequireCMD), where a hierarchical/inheritance chain of *uRequire config* files is used to allow a fine-grained definition of the bundle & build information.\n\nIt is extremelly versatile:\n  - it understands keys both in the 'root' of your config or in 'bundle'/'build' hashes\n  - it provides shortcuts, to convert simple declarations to more complex ones.\n\n### Other features\n- `.coffee` files are valid source modules (.iced, .coco, .ls & .ts are coming). All modules are compiled and parsed only as javascript; module generation is again just javascript (currently - see #14).\n- Improved debugging / warning / informational handling and output.\n- Huge code revamp, can easily be used by other libraries (check `urequireCMD.coffee` & [grunt-urequire](https://github.com/aearly/grunt-urequire)).\n\n### Documentation/development is still WIP\n\nFor details/glimpse check [github.com/anodynos/uBerscore](https://github.com/anodynos/uBerscore) project :\n\n* Just have a glance at the code structure 'uberscore.coffee', u dont have know what each sub-module does.\n* See `examples/uBerscoreExample_XXX.html` and `spec/specRunnerXXX.html` for how each build is used.\n* Check `source/code/uRequireConfig.coffee` & `source/code/uRequireConfig_UMDBuild.json` to see how easilt you can define `bundle`s and `build`s.\n* In `Gruntfile.coffee` check the `urequire:xxx` tasks to see some documented examples\n* For more config documentation (still not-stable & incomplete!) check `source/code/config/uRequireConfigMasterDefaults.coffee`.\n\n___________________________________________________________________________\n\n# Back to v1.x/v2.9 docs\n\n## The hasty coder intro :\n\n### Why ?\n\nThe main drive behind uRequire is to enable you to author **boilerplate-free** *modular javascript code* once, and seamlessly execute & test it everywhere (for now **browser** & **nodejs**).\n\nWith a simple build step, uRequire converts your modules to UMD (& more) using static code analysis, a code generation template system and build/runtime path resolution along with other runtime goodies.\n\n### How ?\n\nYour source can be written either in the 'strict' AMD format `define([], function(){})` or the nodejs/commonjs `require('dep')`.\n\nBut, you can also use a *relaxed* or *hybrid* version, (eg. use asynch `require([], fn)`s everywhere) and extra kinky features.\n\nuRequire converts it to suitable UMD format that can be deployed everywhere.\n\n### Extras ? Kinky ?\n\n * You don't need to surround you code with any UMD-like boilerplate\n\n * Universal [path translations](https://github.com/anodynos/uRequire#bundleRelative-vs-fileRelative-paths), eg from `../../../PersonModel` to `data/PersonModel`\n\n * Never miss a `require('')` declaration on `define([],...)` that [halts your app](https://github.com/anodynos/uRequire#never-miss-a-dependency)\n\n * You can use **RequireJS [loader plugins](https://github.com/anodynos/uRequire#requirejs-loader-plugins)**\n\n * Forget hand-coding boring module features like exporting to [`root`/`global`/`window`](https://github.com/anodynos/uRequire#simplified-rootexports), or implementing [`noConflict()`](https://github.com/anodynos/uRequire#no-worries-noconflict) etc.\n\n**`{\"uDeclare\": \"uRequire does all this magic for you.\"}`**\n\n### Moto\n\n**if you have sensibly `define`d it, u`Require` will find it**\n\n*if you're in hurry to code, jump to [features](https://github.com/anodynos/uRequire#features-at-a-glance) and if you wanna hit 'build' goto [Module authoring](https://github.com/anodynos/uRequire/#module-authoring).*\n\n## The cautious Architect's intro: *Ultimate Aims*\n\n### A Universal Module Converter\n\nRight now uRequire converts only from *AMD and/or nodejs* **to UMD**  and **to pure AMD/nodejs**.\n\nThe aim is to provide conversion TO and FROM *ANY* JavaScript module systems. Many are obvious (eg Harmony) but it should also convert (and/or provide transparent runtimes) for plain old html `<script/>` (eg. to help authors of generic .js libs).\n\nuRequire is using a [flexible template](https://github.com/anodynos/uRequire/tree/master/source/code/templates/ModuleGeneratorTemplates.coffee) written in pure Coffeescript, that can do wonders, albeit simple. An average CS coder would need <30 minutes for a 10 liner template like ['nodejs'](https://github.com/anodynos/uRequire/tree/6d04decd63e/source/code/templates/ModuleGeneratorTemplates.coffee#L146-161).\n\n### Boilerplate no more!\n\nuRequire removes the *mud* from **UMD**, which is currently the *only true option* for cross-platform modular javascript development, but its *ugly*.\n\nU will no longer add UMD around your **non-modular code** to AMDdify the *deployment*.\nU are empowered to use modules to **better structure your code** during *development*.\n\nKeep it DRY!\n\n### Fix pains, Relax, 'Just do it'\n\nThe aim is to cater for (m)any format intricacies and fix (m)any common pains, problems and omissions from module definition formats.\n\nuRequire provides the *simplest possible* authoring of **modular javascript code** with a *relaxed* dependencies structure for modules, using the 'good parts' from AMD and nodejs. It brings browser-side best practices (that appear to be [AMD/requirejs](http://requirejs.org/)) closer to nodejs. And vise versa.\n\nIt helps you have natural & flexible structuring and refactoring of javascript code.\n\n### Unlock and 'Do it just'\n\nuRequire empowers code reuse & modularity without one-side locking.\n\nThe lost **Java** dream of cross-platform execution (that flopped on browser) is becoming true with JavaScript *(the [10day toy language](http://en.wikipedia.org/wiki/Brendan_Eich)!, that won the browser and now nodejs takes Jobol to the server race. And then you have WinJS, appcelerator/mobile and who knows what in a few years!)*\n\nThe aim is that when no browser/DOM or nodejs specifics are present, the same source code runs & tests on both *browser* and *nodejs* (and go on for WinJS, Titanium and whatever:-).\n\n### Functionality injection\n\nuRequire can generate code and inject it on modules. With flexible templates (& parsers), it can also convert *code structure*.\n\nHence popular *standardized* functionalities and structures (like [`noConflict()`](https://github.com/anodynos/uRequire/tree/6d04decd63e/source/code/templates/ModuleGeneratorTemplates.coffee#L74-92)), no longer have to be *hand-crafted*. The less code u write, the less errors and barriers!\n\nuRequire empowers a form of *declarative feature injection* for modules.\n\n## Features at a glance\n\n* Based on a 'familiar' standardized [*UMD template*](https://github.com/umdjs/umd/blob/master/returnExports.js) with optional global exports based on [returnExportsGlobal.js](https://github.com/umdjs/umd/blob/master/returnExportsGlobal.js). Also it converts to [native nodejs or AMD](https://github.com/anodynos/uRequire#convert-to-pure-amd-or-pure-node) - the latter usefull for r.js optimization & bundling.\n\n* **Accomodates both `define()` and `require()` to work the same way in both browser & node.**\n\n    * Specifically, the browser AMD-style `require([..], function(..){})` works on nodejs, just as it does on the browser: [asynchronously](https://github.com/anodynos/uRequire#asynchronous-require).\n\n    * And vise versa, the node-style `var a = require('a')` also works on browser (at least seemingly) [synchronously](https://github.com/anodynos/uRequire#synchronous-require).\n\n    * Finally, `define` is 'worked' inside UMD to behave as expected on both web & nodejs.\n\n\n* Automatically fills missing `require('')` dependencies from [], that would otherwise [halt your app @ runtime, since *requirejs scan* is off](https://github.com/anodynos/uRequire#never-miss-a-dependency).\n\n* Resolves paths dependencies between formats, allowing modules to transparently have a *bundle-root* as a reference point (eg `models\\PersonModel`) that [works in both Web/AMD and nodejs](https://github.com/anodynos/uRequire#bundleRelative-vs-fileRelative-paths).\n\n* Declaratively generates the boilerplate for [`rootExports`](https://github.com/anodynos/uRequire#simplified-rootExports) (global variables to export, eg '_', '$' etc), from a simple declarative setting, on any module. Additionally [`noConflict()`](https://github.com/anodynos/uRequire#no-worries-noconflict) boilerplate code can be produced on any module, again declarativelly.\n\n* Checks your dependencies are valid at build time. It identifies dependencies within bundle boundaries and whether those exist.\nIt also identifies and works with 'globals', 'externals', ['webRootMap',  'requireJS baseUrl/paths'](https://github.com/anodynos/uRequire#mappings) etc. In future versions uRequire will check their validity, before deploying.\n\n* Use [loader plugins](https://github.com/anodynos/uRequire#requirejs-loader-plugins) everywhere, web or nodejs.\n\n* Requires no additional dependency on Web AMD/RequireJs. On nodejs you 'll need `npm install urequire` to execute UMD modules, which gives you extra [deployment functionality](https://github.com/anodynos/uRequire#deployment-options).\n\n##Module authoring\n\nWith uRequire, your modules can be either written in AMD:\n\n```js\n// standard anonymous module format\ndefine(['dep1', 'dep2'], function(dep1, dep2) {\n   // do stuff with dep1, dep2\n   return {my:'module'}\n});\n\n// or a named module\ndefine('moduleName', ['dep1', 'dep2'], function(dep1, dep2) {...});\n\n// or a module without *array* dependencies\ndefine(function() {...})\n```\n\nor in the CommonJs/nodejs format:\n\n```js\nvar dep1 = require('dep1');\nvar dep2 = require('dep2');\n// do stuff with dep1, dep2\nmodule.exports = {my: 'module'}\n```\n\nor a *relaxed** combination of both:\n\n```js\n// uRequire relaxed notation\ndefine(['dep1', 'dep2'], function(dep1, dep2) {\n   var dep3 = require('dep3');\n   // do stuff with dep1, dep2, dep3\n   return {my:'module'}\n});\n```\n * *relaxed means you dont need to be strict to either standard, but also it would NOT work as a plain AMD/nodejs module without uRequire conversion.*\n\nuRequire strives to guarantee that your modules are correctly translated and execute on both target environments, even though the easier, less verbose *relaxed* format is used.\n\nThe idiosyncrasies and limitations of module formats are waived, so you can focus on what is important: you modular code that can be expresed in the easiest sensible way possible.\n\nFor instance you can use both the syntax of sync & asych require, mix absolute/bundleRelative with fileRelative paths, forget about requiring `require` or `module`/`exports` and just be sure that your code will execute on both runtimes in a consistent way.\n\n\n### *bundleRelative* VS *fileRelative* paths\n\nYou can use *bundleRelative* (i.e. absolute 'depdir/dep') or *fileRelative* (i.e relative '../../dep') paths interchangeably.\n\n* On node, dependencies are relative ONLY to requiring file (aka *fileRelative*), which I feel is a source of misconceptions on modularization it self, in regards to development: what happens if you move a file ? what does that dotted path mean ?\n\n* Vanilla AMD/RequireJS on browser works with `fileRelative`, but also allows an absolute *bundleRelative* path like `models\\PersonModel`, relative to some 'bundle', i.e. `baseUrl`.\n\nuRequire allows you to use both semantics, no matter what you write in (nodejs/AMD), as it converts them (at build and execution time on node) to work on both runtimes.\n\nThere are cases that [both are usefull](https://github.com/anodynos/uRequire#mix-them-up), so mix 'em up!\n\n### Synchronous require\n\nU can use the simple `require('depdir/dep')` anywhere you like (nodejs or AMD), without any worries: there is automation.\n\n#### No more require, module, exports\n\nYou dont need to define 'require' as an AMD dependency, or use a param 'module', 'exports' when you use the nodejs `require('')` notation. Its done for you:\n\n* Just write your module using AMD structure `define(['dep1'],fn(dep1){})`, and use `require('dep2')` as you would normally do on nodejs - no need to add 'require' as the first dependency on [].\n\n* or use the plain nodejs notation with `var m = require('m')`, having a `module.exports = myModule;` somewhere.\n\nYour modules will convert and work in UMD (or AMD or nodejs!).\n\n#### Never miss a dependency\n\nIn RequireJS/AMD runtime, if you have a `require('myDep')` in your main module (factory) code, there are two cases:\n\n   * You are using the [*simplified define wrapper*](http://requirejs.org/docs/api.html#cjsmodule), i.e you have NO dependencies array and have passed require (& company) as parameter(s). RequireJS actually 'scans' your module code at runtime, prefetching all deps in `require('dep')` calls. This works fine, **if you stick to it** (although it might cost on speed).\n\n   * You do have array dependencies - they are preloaded. If you have even one array dep [(even 'require')](https://github.com/jrburke/requirejs/issues/467)), RequireJS doesn't scan for `require` calls to preload at runtime. So, if 'myDep' is missing from [], [**your module/app will halt**](http://www.requirejs.org/docs/errors.html#notloaded).\n\nuRequire automatically fills missing `require('')` dependencies from [] declarations, naturally after having resolved their paths.\n\n### Asynchronous require\n\nU can use the *asynchronous* (array) version of require `require(['...'], function(){...})`, anywhere you like, web or nodejs.\n\nKeep in mind that the asynchronous require is essentially the only way to *conditionally* load 'myHugeButOptionalModule' on the web/AMD side. For instance,\n\n```js\n\nif (true) {// perhaps some code here,\n        // to conditionally call asynch 'require' bellow\n  require(['depdir/dep1', 'depdir/dep2'], function(dep1, dep2) {\n    // module factory function\n    // called asynchronously & after dep1 & dep2 are loaded\n    // module returned here\n  });\n}\n// code here is executed immediatelly after calling `require`,\n// BEFORE calling the factory function, since its asynchronous.\n```\nThe asynch require always runs asynchronously on nodejs, just like it does on Web RequireJS/AMD.\n\n*Note: versions of RequireJS < 2.1.x were not consistent on the asynchronous call of require(['dep1', 'dep2'], fn): if all your dependencies ['dep1', 'dep2'] had already been loaded/cached before, the call to fn was actually synchronous. uRequire now matches the behaviour of the latest RequireJS (always asynch).*\n\n### Exporting root (global) variables with noConflict() (WEB/AMD)\n\n#### Simplified `rootExports`\n\nYou can declaratively export one (or more) global variables from your UMD module on the web side: just include an object literal **on the top** of your (source) module file like this:\n\n```js\n({urequire: { rootExports: 'uBerscore' } });\n```\n\nOr use an array :\n\n```js\n({urequire: { rootExports: ['uBerscore', '_B']}});\n```\n\nin case you want many global vars.\n\nThese globals be created as keys on 'root' (eg `window` on browsers), with the module as the value (possibly overwriting existing keys).\n\n#### No worries, `noConflict`\nIf you want to save existing root keys and return to their original value at some point, you can use `noConflict`, with similar behaviour to [jQuery's](api.jquery.com/jQuery.noConflict/).\n\nAgain, you do this declaratively:\n```js\n({\n  urequire: {\n    rootExports: ['_B', 'uBerscore'],\n    noConflict: true\n  }\n});\n```\n\nAt some point in your code, you can call `var myB = _B.noConflict();` which will revert *all* rootExports variables to their original values, returing the module which you can store elsewhere.\nIn future uRequire versions you'll be able to pass an 'exclude' array param & do a `rootExports()` to re-export root vars.\n\nMore declarative options will follow :-)\n\n### Mappings\n\n* You can map webRootMap `/` to a directory of your nodejs environment (--webRootMap option). The directory can be relative to bundle (paths starting with a `.`) or an absolute file system path (eg `/dev/jslibs`). Just make sure your Web Server has the right content mapped to `/` and you're set!\n\n* You can use the requirejs config `baseUrl` and `paths` on nodejs (only those for now) - just place a file named `requirejs.config.json` in your bundle root directory, with content like {\"paths\": {\"myLib\" : \"../../myLib\"}}. Very usefull for 'importing' bundles, eg running specs against 'myLib' bundle using mocha, jasmine-node etc. Again, use the same config items on RequireJS/Web for transparent cross platform module usage.\n\n### RequireJS loader plugins\n\nYou can use *native* [loader plugins](http://requirejs.org/docs/api.html#plugins) (those that make sense in node?) just like any other module.\n\nFor example:\n\n`var myText = require('text!myTextFile.txt')`\n\nor\n\n`define(['json!myjson.json'], function(theJson){...})`\n\nuRequire uses *RequireJS for node* to actually load the plugin and let it do the actual loading work.\n\nYou can just put them on your `bundleRoot` and use them right away. For example to use `\"text!myText.txt\"` you 'll need to copy [`text.js`](https://github.com/requirejs/text/blob/master/text.js) on your bundleRoot, or put it in a folder relative to bundleRoot and note it on `requirejs.config.json` - see `examples/abc`.\n\nOnly 2 plugins have been tried so far (text, [json](https://github.com/millermedeiros/requirejs-plugins/blob/master/src/json.js)), but most that dont rely on browser features should work...\n\n\n### Authoring Notes\n\n* Your `require`s must use a string, eg `require('myModule')`. Requires that evaluate at runtime, eg `require(myVar + 'module')` can't be possibly be evaluated at parse time, and thus are *unsafe*.\n\n* Your module `define(..)` must be a top level in your .js (not nested inside some other code).\n\n* Everything outside `define` is simply ignored.\n\n* Only one module per file is expected - i.e only the first `define` per file is parsed.\n\n* You can use the `.js` extension (but why?), as it is allowed by nodejs. Because of the [different semantics in RequireJS](http://requirejs.org/docs/api.html#jsfiles), its fixed(i.e stripped) for you if needed (i.e it exists on your bundle dir).\n\n* There are some limitations due to the parser/code generator used ([uglifyjs](https://github.com/mishoo/UglifyJS)) : a) Comments are ignored and b) some [unsafe transformations](https://github.com/mishoo/UglifyJS#unsafe-transformations). This will change sometime, when the parser changes to [UglifyJS2](https://github.com/mishoo/UglifyJS2) or [esprima](esprima.org).\n\n### Authoring modules finale\n\nShould you choose to adhere to the 100% [standard syntax of AMD](https://github.com/amdjs) or [nodejs](http://nodejs.org/api/modules.html), so that your pre-build *source* code is also valid/executable too, that's fine.\n\nuRequire will at least be as good as:\n\na) converting them to the 'other' runnable version, should you require it\n\nand\n\nb) perform sanity and dependency checks on your source before deploying (and get a report {-v --verbose}) while fixing common AMD errors like [missing a dep](https://github.com/anodynos/uRequire#never-miss-a-dependency).\n\n## Deployment options\n\n### Web\n\n * There is no additional dependency when UMDs are running on Web (AMD/RequireJS) - use them as you would use strict AMD modules. Naturally your UMDs can work seamlessly with other 'native' AMD modules.\n\n * If you want to optimize your modules and bundle them using r.js or almond etc, you can [convert your modules to AMD](https://github.com/anodynos/uRequire#convert-to-pure-amd-or-pure-node) instead of UMD, and pass them through r.js as you would normally do. uRequire will do this in one step in future versions (>=0.3).\n\n### nodejs\n\n * On nodejs, as long as 'urequire' package is installed via npm, your UMD generated modules can be used as-is by any UMD or native nodejs module via the bare `require('')` call. Although your source modules were written in AMD and perhaps use asynchronous require calls, plugins etc they work seamlessly on nodejs.\n\n * Additionally your ex-AMD, now UMDfied modules, can `require('module')` any *node-native module* installed via npm or residing on your file system. Its *MAD*, but RequireJS AMD modules wont let you do that (@version 2.1.1). * **Note: you have to conditionally make sure the node-natives aren't called/executing on browser; or better replace them with some client counterpart lib!** If you want to `require('')` a node-only module, that shouldn't be [added to the deps array](https://github.com/anodynos/uRequire#never-miss-a-dependency), use the `node!moduleName` pseudo-plugin, that signals node-only execution. *\n\n * You can use *native RequireJS loader plugins* (eg `text!mytext.txt`), through RequireJS it self. Your nodejs-looking modules can actually use RequireJS plugins.\n\n * Finally you can run *native AMD modules* on node (ones that aren't converted to UMD, i.e start with `define()`). If uRequire fails to load a module,\n it passes it to RequireJS/node it self - this needs more testing, but it does the trick for now.\n\n### Convert to pure AMD or pure node:\n\nYou can issue a `urequire AMD ...` or `urequire nodejs` instead of the standard/recommended UMD (Universal Module Definition) format.\n\nDo note:\n\n  * *AMD*-only is safe & 100% equivalent for web execution with its UMD counterpart. Its also what you need to [r.js optimize](http://requirejs.org/docs/optimization.html).\n\n  * *nodejs*-only is not recommended. It converts modules with a *pure* **nodejs** template, without uRequire's special [`require`](https://github.com/anodynos/uRequire/blob/master/source/code/NodeRequirer.coffee), thus loosing a lot of functionality:\n\n      * Runtime translation of paths like `models/PersonModel` to `../../models/PersonModel`, depending on where it was called from.\n      * Can't use the asynchronous version of `require(['dep'], function(dep){...})`\n      * Can't runn of loader plugins, like `text!...` or `json!...`\n      * There's no mapping of `/`, ie webRootMap etc or using the requirejs.config's `{baseUrl:\"....\"} or {paths:\"lib\":\"../../lib\"}`\n\n    You 'll still get build-time translated bundleRelative paths, to their nodejs fileRelative equivalent.\n\n    Converted modules dont have a dependency on `npm install uRequire` to run, but the whole thing is too restrictive.\n    Neverthelss, if you're not using any of the above features, uRequire is a fine AMD-to-nodejs converter (but misses comments:-(, for now :-).\n    For a similar even simpler conversion (no path translation), see ['nodefy'](https://github.com/millermedeiros/nodefy).\n\n\n##Installation & Usage\n\nuRequire has a command line converter that needs to be called globally:\n\n  `npm install urequire -g`\n\nYou 'll also need a local dependency of `'urequire'` for your modules-to-become-UMD, when those are running on node, so install locally also `npm install urequire` or add to your package.json. This actually gives your UMD modules a proxy to node's native require, allowing proper [paths resolution](https://github.com/anodynos/uRequire#bundleRelative-vs-fileRelative-paths), the [asynchronous](https://github.com/anodynos/uRequire#asynchronous-require) version of require, [loader plugin execution](https://github.com/anodynos/uRequire#requirejs-loader-plugins), [mappings](https://github.com/anodynos/uRequire#mappings) and better debugging information when things go wrong.\n\nAssuming you have your AMD/node modules in a structure like this\n<pre>\nsrc/\n    Application.js\n    views/\n          PersonView.js\n    models/\n          PersonModel.js\n    helpers/\n          helper.js\n</pre>\n\nThe src/ directory is said to be your 'bundle root', in urequire terms. It's what you would set `baseUrl` to in requirejs, if your modules were in pure AMD format. All absolute dependencies (those not starting with `./`, `../` or `/`) would be relative to this bundle root, eg 'Application' or 'views/PersonView'. Every UMD file is aware of its location in the bundle and uses it in various ways, such as resolving paths, looking for 'requirejs.config.json', resolving baseUrl/paths & webRootMap etc.\n\nNow say your `views/PersonView.js` is\n\n```js\ndefine(['models/PersonModel'], function(PersonModel) {\n  var helper = require('helpers/helper.js');\n  //do stuff with PersonModel & helper\n  return {the:'PersonViewModule'}\n});\n```\n\nand similarly for the others. Note that the above is using the 'relaxed' form.\n\nRemember that other modules in the same bundle can be authored as nodejs modules. For example  'models/PersonModel.js' can be :\n\n```js\nvar helper = require('helpers/helper.js');\nvar data = require('datastore/data.js');\n// do stuff with data & helper\nmodule.exports = {the:'PersonModelModule'}\n```\n\nTo convert your modules to uRequire UMD you 'll execute:\n\n```\nurequire UMD src -o build\n```\n\nThis will place the translated UMD files into the `build` directory.\nThe generated files will look similar to this:\n\n```js\n  // Generated by urequire v0.0.9\n  (function (root, factory) {\n      if (typeof exports === 'object') {\n          var nodeRequire = require('urequire').makeNodeRequire('views/PersonView.js', __dirname, '..');\n          module.exports = factory(nodeRequire, nodeRequire('../models/PersonModel'));\n      } else if (typeof define === 'function' && define.amd) {\n          define(['require', '../models/PersonModel', '../helpers/helper.js'], factory);\n      }\n  })(this, function (require, PersonModel) {\n      var helper = require('../helpers/helper.js');\n      return {the:'PersonViewModule'};\n  });\n```\n\nYour bundle files are ready to be deployed to Web/RequireJS and to node (by having 'urequire' locally installed via npm).\n\n### CMD options\n  -h, --help                     output usage information\n\n  -V, --version                  output the version number\n\n  -o, --outputPath <outputPath>  Output converted files onto this directory\n\n  -f, --forceOverwriteSources    Overwrite *source* files (-o not needed & ignored). Usefull if your source is not *real source*, eg you use coffeescript\n\n  -v, --verbose                  Print module processing information\n\n  -n, --noExport                 Ignore all web `rootExport`s in module definitions\n\n  -r, --webRootMap <webRootMap>  Where to map `/` when running in node. On RequireJS its http-server's root. Can be absolute or relative to bundle. Defaults to bundle.\n\n  -s, --scanAllow                By default, ALL require('') deps appear on []. to prevent RequireJS to scan @ runtime (event if there was none on []). With --s you can allow `require('')` scan @ runtime, for source modules that have no [] deps (eg nodejs source modules)\n\n  -a, --allNodeRequires          Pre-require all deps on node, even if they arent mapped to parameters, just like in AMD deps []. Preserves same loading order, but a possible slower starting up on node. They are cached nevertheless, so you might gain speed later.\n\n  -C, --Continue                 Dont bail out while processing (mainly on module processing errors)\n\n\n## FAQ\n\n### What exactly is the problem with AMD running on web / node as it is ? Why not use RequireJS / amdefine on node ?\n\nThere are various problems with modules in the current era.\n\nYes, RequireJS [can be be used on node](http://requirejs.org/docs/node.html). Installed as a local package via npm its a large 600kb dependency, but that is not the problem.\n\n* RequireJS on node is strict on dependencies declarations on node, just like on web execution: if you ommit declaring a dependency on the dependency array `define(['dep']...)`, it [will fail when you require('dep')](https://github.com/jrburke/requirejs/issues/467) on the body (on node it actually returns 'undefined'). Also, if you forget to list 'require' as your first dependency, you'll unleash hell: it'll work in some cases and some paths, not in others. This is all expected, due to the 'strictness' of the AMD standard. Hence, even this is not really the problem, just a caveat.\n\n* The real problem stems from the need to load your AMD-defined modules via RequireJs special 'adapter' (loader). Taken from its documentation :\n\n```js\nvar requirejs = require('requirejs');\nrequirejs.config({nodeRequire: require});\nrequirejs(['foo', 'bar'], function(foo, bar) {});\n```\n\nThis works ok for *your* AMD defined modules. But if you need to use a node-native .js module, residing on your file system, r.js fails with `Error: Evaluating '/path/to/myLib.js' as module \"myLib\" failed with error: ReferenceError: module is not defined`. See `examples/rjs`\n\nOne may ask, *why would I need to load native nodejs modules from AMD/UMD modules that are supposed to be runnable on the web side mainly/also ?*. One simple answer is *cause you wanna share code between client & server, but also be able to inject code on either side at will*. Perhaps this issue is a single stopper for using AMD on node.\n\nuRequire modules overcome this problem: they can require any native node module as it is, without any special treatment, adapter or conversion. Third party code can get 'required' and work as it is. You only need to use the fake-plugin notation of `require('node!./path/to/nativeNodeJsModule')`, to signal that this module should not appear on AMD dependency array & then make sure at runtime that it gets loaded only when you are at nodejs (`isNode` & `isWeb` variables are provided for this purppose). See `examples/nodeNative-requiredByABC_and_rjs` and `examples\\abc\\a-lib`.\n\n* Similarly, your AMD defined modules can't be used by node-native modules as they are with requireJS. Your AMD modules start with `define`, which is unknown to the node runtime.\nSo your node-native requiring modules need to be changed and instead load your native AMD-modules through requirejs, which means you need to alter them. This doesn't work if they happen to be third party code, or testers or other kind of loaders. And I think its a heavy burdain by it self, even if its your own code. You should be focusing on you business logic, not how to load modules.\n\n* Path resolution is also problematic, relative & absolute paths are causes of problems and it breaks on testers like mocha or when you want to use multiple 'bundles' in one requiring module. Check [this](https://github.com/jrburke/amdefine/issues/4) and [this](https://github.com/jrburke/requirejs/issues/450) issues.\n\n* Copying from requirejs [docs](http://requirejs.org/docs/node.html#2) *Even though RequireJS is an asynchronous loader in the browser, the RequireJS Node adapter loads modules synchronously in the Node environment to match the default loading behavior in Node*. I think this can lead to problems, where asynch based code that is developed and tested on node runs ok, but fails miserably when it runs on web. Module systems should execute the same way on all sides, to the maximum possible extend.\n\nEdit: This behaviour was fixed in RequireJS 2.1 ['Enforcing async require'](https://github.com/jrburke/requirejs/wiki/Upgrading-to-RequireJS-2.1). uRequire endevours to match RequireJS's functionality, following its newest version's behaviour.\n\n* Using [amdefine](https://github.com/jrburke/amdefine/) also leaves a lot to be desired: a single line makes 'define' available on node, but where does 'require' come from ? It comes from node. Hence no bundleRelative paths and no asynch version of require. And if you use the synch/node `module = require('moduleName')`, and works on the node side, you 'll need to remember to include 'require' and 'moduleName' on the dependencies array also. Finally mixing node-requirejs and amdefine is not an option either - they aren't meant to be used together - see some [early failed attempts](https://github.com/jrburke/requirejs/issues/450)\n\n### What does urequire 'relaxed' notation solve ?\n\nConsider this AMD example:\n\n```js\ndefine(['main/dep1', 'main/helpers/dep2'], function(dep1, dep2) {\n   var dep3 = require('moredeps/dep3');\n\n   if (dep3(dep1) === 'wow'){\n      require(['./dep4'], function(dep4) {\n        // asynchronously do things with dep4\n      });\n   }\n\n   // do stuff with dep1, dep2, dep3\n\n   return {my:'module'}\n});\n```\n\nThis looks like a valid AMD module, but it would *not* work as AMD/RequireJS module. (it does only if its 'relaxed' form is massaged by uRequire and converted to UMD).\n\nThe line `var dep3 = require('moredeps/dep3');` would fail on web/requirejs for two reasons:\n\na) `require` is not listed as a dependency\n\nand\n\nb) even if you had `require` listed, your app would halt because `moredeps/dep3` is not listed as a dependency, i.e it is a [missing require dep](https://github.com/anodynos/uRequire#never miss a dependency).\n\n\nFurther more, even if you fixed those two errors, if you were to run this in *node*, you would be missing `define`. You could turn to `amdefine`, but that would also fail on `require('moredeps/dep3')` because of the absolute/bunldeRelative path. Remember, with amdefine, require('') comes from node - i.e. no bundleRelative paths, no plugins, no asynchronous calls. For the last reason, the 2nd require would also fail, since this asynchronous format is not supported on node's require. For more or less the same reasons, you would have issues if you used requirejs on node.\n\nWith UMD produced by uRequire, you would overcome these issues instantly: your module is ready to run on both node and web as it is.\n\n### Can I mix *fileRelative* and *bundleRelative*, or will I get into problems ?\n\nOne core aim of uRequire is to allow you to use either on both environments. At build time everything is translated to what actually works (fileRelative), so you dont need to worry. And at runtime, if you come to evaluate to an absolute path (bundleRelative), it will still work (by default) on web and by (transparent) translation on nodejs.\n\n#### Mix them up\nActually mixing the two path formats, is IMHO probably a good practice:\n\n  * When you require a *local* dependency, eg. something closely related to your current module, you could use the fileRelative notation. For instance if you are writing `utils/string/camelCase` and you need `utils/string/replaceAllChars`, then its logical, obvious and self explanatory to just use `./replaceAllChars`.\n\n  * When you require something more *distant*, you should use the absolute path to show exactly what you mean. For instance, `../../../string/replace` reveals little of where is what you need, where you coming from and whether it is the right path. And if you ever refactor it'll be a nightmare to change 'em all. Its actually more clear to use `utils/string/replace` in these cases.\n\n### Hey, I like it so far, but I think its another format on its own. After all, it violates standards, it's a frankestein, its a tool that if you adopt, u have a dependency on it!\n\nNot really.\n\n* If you stick to the standard AMD or nodeJs, you're fine on that side. And if you avoid using any DOM/node features (like node's `require.resolve()`) you get 'running on the other side' for free.\n\n* If you use AMD 'relaxed' form, but want to go back to AMD strict for web's sake: At any time (with > v0.3) you can convert your 'relaxed' uRequire source to strict AMD and get done with it. You 'll never need uRequire again (but I'm sure you 'll come back!). And your code will still be able to convert to UMD so it runs on node.\n\n* If you use nodeJs with and have used the asynch `require([], function(){})`, and you want to go back to strict node format, you \"ll have some more work to do converting to `var a = require('a')` and changing its asynch nature, but it shouldn't be so hard (the other way around is much harder).\n\n### Hey, I 've heard browserify *makes node-style require() work in the browser with a server-side build step*. Is it similar to this? Is it better ?\n\nSimilar? Better? not really. And at the same time, YES, absolutely!\n\nU can think of this project as a distant counterpart to [browserify](https://github.com/substack/node-browserify), though it takes a completely different approach and has different results:\n\n - uRequire is better/different, because it works both sides: web-to-node and node-to-web.\n Also on web side, its using AMD, which seems to be the standard way to define web modules [AMD](https://github.com/amdjs). The [claim is](http://requirejs.org/docs/whyamd.html) that AMD is the proper browser-optimized module system. But that should not prevent you, from running that same code on nodejs, as it is.\n\n - But NO, its not 'better' than browserify. It doesn't attempt to bring any of node's packages and functionality to the web (like browserify does). Only your modules are the issue here: your code that SHOULD run on both sides, WILL run. U must use non-dom, non-node stuff of course, if you want your code to work both ways.\n\n #### But hey, can I combine them ?\n See below, the FAQuestions with one answser.\n\n### Have you got any examples ?\n\nAll examples are in [uRequireExamples](https://github.com/anodynos/uRequireExamples), the testbed for uRequire & modularity problems/solutions.\n\n#### amd-utils tutorial\n\nCheck a more real world one, UMDfying the amd-utils by [millermedeiros](https://github.com/millermedeiros)\n\n0) Grab a copy of [amd-utils](http://millermedeiros.github.com/amd-utils/)\n\n1) Install urequire in it `npm install urequire` (and globally if u haven't already)\n\n2) Run `urequire UMD src -o UMD/src`, which converts the main library files to uRequire UMD.\n\n3) Copy tests/lib and test/SpecRunner.html into UMD/tests\n\n4) Run `urequire UMD tests/spec -o UMD/tests/spec`, which converts the spec files to uRequire UMD.\n\nAt this point *uRequire will complain that* 'Bundle-looking dependencies not found in bundle' - this is expected: indeed,\nif you run it with `jasmine-node UMD/tests/spec --matchall` it will fail to find `src\\array\\append` etc because it has no idea where `src\\` is.\n\nSo just add a `requirejs.config.json` on the specs bundle root (tests/spec), copying from the requirejs config used in SpecRunner.html:\n\n```js\n{\"paths\": {\"src\" : \"../../src\"}}\n```\n(dont forget to convert to real JSON - ie enclose keys/values with double quotes)\n\nNow if you run jasmine again, almost all tests will run ok, with only two exceptions:\n\n  a) Few specs requring some DOM related objects like `window` and `document`, which is well expected.\n\n  b) Two specs in `spec\\array\\spec-forEach.js` titled 'should support arrays with missing items' fails because uglifyJs that is used by uRequire to parse & regenerate the code is changing the mis_ing-items array `[ 5, ,7 ]` to `[ 5, undefined, 7 ]` and there is nothing I can do about it! Perhaps uglify2 or another parser would solve this...\n\nApart from those, the UMDfied amd-utils library now runs and tests on both browser and nodejs.\n\n###Hey, I dont want to convert my modules. Is it still usefull ?\nOf course. It will run some sanity checks on your module bundles.\nMore examples & functionality, watch this space!\n\n###FAQuestions with one answer.\n\n####Can I safely mix uRequire UMD modules with other 'native' modules, at each runtime (i.e on node and the browser) ?\n####Can I substitute a module at runtime with a different version, at each runtime ? i.e. can I have a different 'data/storage', at each runtime ?\n####Can I combine it with Browserify and make more awesome stuff ?\n####Will it do `this` or work with `that` in the future ?\n####Does it rock ?\n Well, of course. In theory. <= v.0.1 is only a proof of concept.\n I 've tried some configurations, but only a fraction of what's out there of course!\n They should all work, somehow, sometime.\n If they dont, they will.\n See the History / Roadmap below to get a better idea of future directions.\n I am eager to know and realize more usage patterns to incorporate.\n So, go play, try it out and make sure you let me know what issues & successes you're having!\n\n#####BTW, uRequire requires U:\n```coffeescript\nrequire ['volunteers', 'skills/solidjs/CoffeeScript', 'awesomeness'], (volunteers, jscs, awe)->\n    modules = (require 'knowledgeOf/RequireJS/NodeJs/module/systems').preferable()\n    (uTeam.members or= []).push v.welcome() for v in volunteers when (v jscs, modules) is awe;\n\n  uRequire:'v1.0'\n```\n\n## Does `u` in uRequire stems from UMD ?\nNo, from Universal. Require.\n\n## History / Roadmap:\n###v0.1.0 - Alpha/preview release\n* A preview of what uRequire aims to become. Quite usefull as it is, but still a non-stable/Alpha.\n\n###v0.1.5 - Alpha/preview release\n* Working towards refactoring & loaderPlugins - node!, text! & json! are worked out (preliminary)\n\n###v0.1.7\n* support for native RequireJS plugins & native RequireJS modules on node, through RequireJS.\n* Refactoring continues, documentation starting (NodeRequirer)\n\n###v0.1.8\n* Refactoring & documentation continues (on `NodeRequirer`)\n\n###**v0.2.x (Latest/current version)**\n* Refactoring, code documentation, more spec tests, plan for incorporating future functionality.\n\n* (0.1.6) - You can use native [RequireJS loader plugins](https://github.com/anodynos/uRequire#requirejs-loader-plugins) (like text! and json!) - (alpha support).\n\n* Mimics the behaviour of RequireJS's `require(['dep1', 'dep2'], function(){})` where if dependencies 'dep1' & 'dep2' are already loaded (i.e cached), the factory function is called synchronously (immediatelly). **UPDATE: this feature is muted, to match RequireJS 2.1.x behaviour that fixed this.**\n\n* (0.2.2) [AMD only & nodejs only module tranlation](https://github.com/anodynos/uRequire#convert-to-pure-amd-or-pure-node), through respective (buildin) templates:\n  Just give `urequire AMD ....`  or `urequire nodejs ....` instead..\n\n* (0.2.6) [`rootExports`](https://github.com/anodynos/uRequire#simplified-rootExports) can now be an array & [`noConflict()`](https://github.com/anodynos/uRequire#no-worries-noconflict) is declarativelyoffered.\n\n###v0.3 - 0.5\n\n* AMD template along with *r.js* optimization of your relaxed notation modules. Also it will come with the ability to change from fileRelative to bundleRelative and vise versa. This will allow you for instance to automatically translate modules you already have written using the restrictive fileRelative paths '../../../models/PersonModel', to the more natural bundleRelative 'models/PersonModel'. From then on, you 'll use the build as your new source. You'll then simply uRequire 'em into UMD/AMD when you run/deploy. Caveat : uglify 1.x must be swaped with a better .js parser / one that at least supports comments.\n\n* Sanity checks of existence of external libraries, webRootMap, baseUrl, paths etc.\n\n* Watch option / build only changed files / cache bundle/module info, all aiming to quickest translation.\n\n* Grunt plugin ? (still works fine as it is with shell:command)\n\n###v0.6 - v0.8\n\n* Configuration file `urequire.json` that will contain all the information regarding your bundle: your default uRequire settings (eg your nodejs webRootMap mapping, -scanPrevent), and the most important of all: a `relaxed` config used on both the web side and nodejs that knows facts like which are the bundle modules or that `underscore` is a 'global' (i.e it needs a requireJS/web {paths: {'underscore': '/libs/lodash.js'}} and on node its ususally an `npm install underscore`, but it could also use the same requireJs `paths`.) etc.\n\n* Additionally, check jamjs & yeoman, cause they deal with deps management as well... piggyback?\n\n* Investigate loading modules asynchronously from HTTP on node, just like RequireJS/browser (with caching).\n\n###Other issues / unversioned\n* Allow *some* functions of both AMD and Require to be used on the other side, eg nodejs's `require.resolve()`\n\n* Build to an almond-like format where everything in bundled.\n\n* Convert from strict-AMD to relaxed-AMD :-)\n\n##Acknoweledgments.\n**Buidling on the shoulders of giants is always better.** \nuRequire would not have been possible without :\n\n  * [RequireJS](https://github.com/jrburke/requirejs), the most popular web-side module system to date, by [JR Burke](https://gist.github.com/jrburke)\n\n  * [UMDjs](https://github.com/umdjs/umd), provide boilerplates that bridge gaps, by [JR Burke](https://gist.github.com/jrburke) and [others](https://github.com/umdjs/umd#umd-universal-module-definition)\n\n  * [UglifyJS](https://github.com/mishoo/UglifyJS), easily parses/re-generates JavaScript, by [Mihai Bazon](https://github.com/mishoo/)\n\n  * [CoffeeScript](http://coffeescript.org/), makes javascript authoring a true joy, by [Jeremy Ashkenas](https://github.com/jashkenas) et [all](http://github.com/jashkenas/coffee-script/contributors)\n\n  * [Grunt](https://github.com/gruntjs), the best declarative javascript build system, by [Ben Alman](https://github.com/cowboy)\n\n  * [Commander](https://github.com/visionmedia/commander.js), easily parses cmd arguments, by [TJ Holowaychuk](https://github.com/visionmedia)\n\n  * [Codo](https://github.com/netzpirat/codo), for documenting Coffeescript code, by [Michael Kessler](https://github.com/netzpirat)\n\nand all others - see package.json dependencies.\n\n### Further information & articles\n\n* [Writing Modular JavaScript With AMD, CommonJS & ES Harmony](http://addyosmani.com/writing-modular-js/) by [Addy Osmani](http://twitter.com/addyosmani)\n* [Patterns For Large-Scale JavaScript Application Architecture](http://addyosmani.com/largescalejavascript/) by [Addy Osmani](http://twitter.com/addyosmani)\n\n\n\n*PS: Excuse my typo errors, I need to get a solid dictionary for ** WebStorm ** (which otherwise rocks!)*\n\n# License\nThe MIT License\n\nCopyright (c) 2012 Agelos Pikoulas (agelos.pikoulas@gmail.com)\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "readme.md",
  "_id": "urequire@0.3.0beta1",
  "dist": {
    "shasum": "ef307f51b1de98571b6231c868b75d0890f62332"
  },
  "_from": "urequire@0.3.0beta1",
  "_resolved": "https://registry.npmjs.org/urequire/-/urequire-0.3.0beta1.tgz"
}
