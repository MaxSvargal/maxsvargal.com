// Generated by CoffeeScript 1.6.2
var AlmondOptimizationTemplate, Build, Bundle, BundleBase, DependenciesReporter, Dependency, UModule, YADC, getFiles, l, uRequireConfigMasterDefaults, upath, _, _B, _fs, _wrench,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

_.mixin((require('underscore.string')).exports());

_fs = require('fs');

_wrench = require('wrench');

_B = require('uberscore');

l = new _B.Logger('urequire/Bundle');

upath = require('../paths/upath');

getFiles = require("./../utils/getFiles");

uRequireConfigMasterDefaults = require('../config/uRequireConfigMasterDefaults');

AlmondOptimizationTemplate = require('../templates/AlmondOptimizationTemplate');

Dependency = require('../Dependency');

DependenciesReporter = require('./../DependenciesReporter');

UModule = require('./UModule');

Build = require('./Build');

BundleBase = require('./BundleBase');

/*
*/


Bundle = (function(_super) {
  var filesFilter, getFilesFactory, _ref,
    _this = this;

  __extends(Bundle, _super);

  Function.prototype.property = function(p) {
    var d, n, _results;

    _results = [];
    for (n in p) {
      d = p[n];
      _results.push(Object.defineProperty(this.prototype, n, d));
    }
    return _results;
  };

  Function.prototype.staticProperty = function(p) {
    var d, n, _results;

    _results = [];
    for (n in p) {
      d = p[n];
      _results.push(Object.defineProperty(Bundle.prototype, n, d));
    }
    return _results;
  };

  function Bundle() {
    this._constructor.apply(this, arguments);
  }

  Bundle.prototype._constructor = function(bundleCfg) {
    _.extend(this, bundleCfg);
    this.reporter = new DependenciesReporter();
    this.uModules = {};
    return this.loadModules();
    /* handle bundle.bundleName & bundle.main
    */

  };

  Bundle.staticProperty({
    requirejs: {
      get: function() {
        return require('requirejs');
      }
    }
  });

  /*
  Read / refresh all files in directory.
  Not run everytime there is a file added/removed, unless we need to:
  Runs initially and in unkonwn -watch / refresh situations (@todo:NOT IMPLEMENTED)
  */


  _ref = {
    filenames: function(mfn) {
      return !_B.inAgreements(mfn, this.ignore);
    },
    moduleFilenames: function(mfn) {
      return !_B.inAgreements(mfn, this.ignore) && _B.inAgreements(mfn, this._knownModules);
    },
    processModuleFilenames: function(mfn) {
      return _B.inAgreements(mfn, this._knownModules) && (!_B.inAgreements(mfn, this.ignore)) && (_B.inAgreements(mfn, this.processModules) || _.isEmpty(this.processModules));
    },
    copyNonModulesFilenames: function(mfn) {
      return !_B.inAgreements(mfn, this.ignore) && !_B.inAgreements(mfn, this._knownModules) && _B.inAgreements(mfn, this.copyNonModules);
    }
  };
  for (getFilesFactory in _ref) {
    filesFilter = _ref[getFilesFactory];
    Bundle.property(_B.okv({}, getFilesFactory, {
      get: (function(getFilesFactory, filesFilter) {
        return function() {
          var deletedFiles, err, existingFiles, file, files, newFiles, _i, _len, _name;

          existingFiles = (this[_name = "_" + getFilesFactory] || (this[_name] = []));
          try {
            files = getFiles(this.bundlePath, _.bind(filesFilter, this));
          } catch (_error) {
            err = _error;
            err.uRequire = "*uRequire " + l.VERSION + "*: Something went wrong reading from '" + this.bundlePath + "'.";
            l.err(err.uRequire);
            throw err;
          }
          newFiles = _.difference(files, existingFiles);
          if (!_.isEmpty(newFiles)) {
            l.verbose("New " + getFilesFactory + " :\n", newFiles);
            for (_i = 0, _len = newFiles.length; _i < _len; _i++) {
              file = newFiles[_i];
              existingFiles.push(file);
            }
          }
          deletedFiles = _.difference(existingFiles, files);
          if (!_.isEmpty(deletedFiles)) {
            l.verbose("Deleted " + getFilesFactory + " :\n", deletedFiles);
            this.deleteModules(deletedFiles);
            this["_" + getFilesFactory] = files;
          }
          return files;
        };
      })(getFilesFactory, filesFilter)
    }, Bundle));
  }

  /*
    Processes each module, as instructed by `watcher` in a [] paramor read file system (@moduleFilenames)
    @param @build - see `config/uRequireConfigMasterDefaults.coffee`
    @param String or []<String> with filenames to process.
      @default read files from filesystem (property @moduleFilenames)
  */


  Bundle.prototype.loadModules = function(moduleFilenames) {
    var err, fullModulePath, moduleFN, moduleSource, _i, _len, _ref1, _results;

    if (moduleFilenames == null) {
      moduleFilenames = this.processModuleFilenames;
    }
    _ref1 = _B.arrayize(moduleFilenames);
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      moduleFN = _ref1[_i];
      fullModulePath = "" + this.bundlePath + "/" + moduleFN;
      try {
        moduleSource = _fs.readFileSync(fullModulePath, 'utf-8');
        if (this.uModules[moduleFN]) {
          if (uM.sourceCode !== moduleSource) {
            delete this.uModule[moduleFN];
          }
        }
        if (!this.uModules[moduleFN]) {
          _results.push(this.uModules[moduleFN] = new UModule(this, moduleFN, moduleSource));
        } else {
          _results.push(void 0);
        }
      } catch (_error) {
        err = _error;
        l.debug(80, err);
        if (!_fs.existsSync(fullModulePath)) {
          l.log("Missing file '" + fullModulePath + "', removing module '" + moduleFN + "'");
          if (this.uModules[moduleFN]) {
            _results.push(delete this.uModules[moduleFN]);
          } else {
            _results.push(void 0);
          }
        } else {
          err.uRequire = "*uRequire " + l.VERSION + "*: Something went wrong while processing '" + fullModulePath + "', for module '" + moduleFN + "'.";
          l.err(err.uRequire);
          throw err;
        }
      }
    }
    return _results;
  };

  /*
  @build / convert all uModules that have changed since last @build
  */


  Bundle.prototype.buildChangedModules = function(build) {
    var haveChanges, mfn, report, uModule, _ref1;

    this.build = build;
    if (this.build.template.name === 'combined') {
      if (!this.build.combinedFile) {
        this.build.combinedFile = upath.changeExt(this.build.outputPath, '.js');
        this.build.outputPath = "" + this.build.combinedFile + "__temp";
        if (l.deb(30)) {
          l.debug("Setting @build.combinedFile =", this.build.outputPath, ' and @build.outputPath = ', this.build.outputPath);
        }
      }
    }
    this.copyNonModuleFiles();
    haveChanges = false;
    _ref1 = this.uModules;
    for (mfn in _ref1) {
      uModule = _ref1[mfn];
      if (!uModule.convertedJs) {
        haveChanges = true;
        uModule.convert(this.build);
        if (_.isFunction(this.build.out)) {
          this.build.out(uModule.modulePath, uModule.convertedJs);
        }
      }
    }
    report = this.reporter.getReport(this.build.interestingDepTypes);
    if (!_.isEmpty(report)) {
      l.log('Report for this `build`:\n', report);
    }
    if (this.build.template.name === 'combined') {
      if (haveChanges) {
        return this.combine(this.build);
      } else {
        return this.build.done(true);
      }
    } else {
      return this.build.done(true);
    }
  };

  Bundle.prototype.getRequireJSConfig = function() {
    return {
      paths: {
        text: "requirejs_plugins/text",
        json: "requirejs_plugins/json"
      }
    };
  };

  Bundle.prototype.copyAlmondJs = function() {
    var err;

    try {
      return Build.copyFileSync("" + __dirname + "/../../../node_modules/almond/almond.js", "" + this.build.outputPath + "/almond.js");
    } catch (_error) {
      err = _error;
      err.uRequire = "uRequire: error copying almond.js from uRequire's installation node_modules - is it installed ?\nTried: '" + __dirname + "/../../../node_modules/almond/almond.js'";
      l.err(err.uRequire);
      throw err;
    }
  };

  Bundle.prototype.copyNonModuleFiles = function() {
    var cnmf, fn, _i, _len, _results;

    cnmf = this.copyNonModulesFilenames;
    if (!_.isEmpty(cnmf)) {
      l.verbose("Copying non-module/excluded files : \n", cnmf);
      _results = [];
      for (_i = 0, _len = cnmf.length; _i < _len; _i++) {
        fn = cnmf[_i];
        _results.push(Build.copyFileSync("" + this.bundlePath + "/" + fn, "" + this.build.outputPath + "/" + fn));
      }
      return _results;
    }
  };

  /*
   Copy all bundle's webMap dependencies to outputPath
   @todo: should copy dep.plugin & dep.resourceName separatelly
  */


  Bundle.prototype.copyWebMapDeps = function() {
    var depName, webRootDeps, _i, _len, _results;

    webRootDeps = _.keys(this.getDepsVars({
      depType: Dependency.TYPES.webRootMap
    }));
    if (!_.isEmpty(webRootDeps)) {
      l.verbose("Copying webRoot deps :\n", webRootDeps);
      _results = [];
      for (_i = 0, _len = webRootDeps.length; _i < _len; _i++) {
        depName = webRootDeps[_i];
        _results.push(Build.copyFileSync("" + this.webRoot + depName, "" + this.build.outputPath + depName));
      }
      return _results;
    }
  };

  Bundle.prototype.deleteModules = function(modules) {
    var m;

    if (l.deb(30)) {
      return l.debug((function() {
        var _i, _len, _results;

        if (this.uModules[m]) {
          _results = [];
          for (_i = 0, _len = modules.length; _i < _len; _i++) {
            m = modules[_i];
            _results.push("delete " + this.uModules[m]);
          }
          return _results;
        }
      }).call(this));
    }
  };

  /*
  */


  Bundle.prototype.combine = function(build) {
    var almondTemplates, err, fileName, genCode, globalDepsVars, mainModuleCandidate, optimize, optimizeMethod, optimizers, rjsConfig, _i, _len, _ref1, _ref2,
      _this = this;

    this.build = build;
    if (!this.main) {
      _ref1 = [this.bundleName, 'index', 'main'];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        mainModuleCandidate = _ref1[_i];
        if (!(mainModuleCandidate && !this.main)) {
          continue;
        }
        this.main = _.find(this.moduleFilenames, function(mf) {
          var ext, _j, _len1, _ref2;

          _ref2 = Build.moduleExtensions;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            ext = _ref2[_j];
            if (mf === mainModuleCandidate + ("." + ext)) {
              return true;
            }
          }
          return false;
        });
        if (this.main) {
          this.mainExt = this.main;
          this.main = upath.trimExt(this.main);
          l.warn("combine() note: 'bundle.main', your *entry-point module* was missing from bundle config(s).\nIt's defaulting to " + (this.main === this.bundleName ? 'bundle.bundleName = ' : '') + "'" + this.main + "', as uRequire found an existing '" + this.bundlePath + "/" + this.mainExt + "' module in your bundlePath.");
        }
      }
    }
    if (!this.main) {
      l.err("Quiting cause 'bundle.main' is missing (after so much effort).\nNo module found either as bundleName = '" + this.bundleName + "', nor as ['index', 'main'].");
      return this.build.done(false);
    } else {
      globalDepsVars = this.getDepsVars({
        depType: Dependency.TYPES.global
      });
      if (_.any(globalDepsVars, function(v, k) {
        return _.isEmpty(v);
      })) {
        l.err("Quiting cause some global dependencies are missing a variable binding:\n\n" + (l.prettify(_B.go(globalDepsVars, {
          fltr: function(v) {
            return _.isEmpty(v);
          }
        }))) + "\n\nThese variable names are used to grab the dependency from the global object, when running as <script>.\nEg. 'jquery' corresponds to '$' or 'jQuery', hence it should be known as `jquery: ['$', 'jQuery']`\n\nRemedy:\n\nYou should add it at uRequireConfig 'bundle.dependencies.variableNames' as:\n  ```\n    variableNames: {\n      'myDep1': 'VARIABLE_IT_BINDS_WITH',\n      'myDep2': ['VARIABLE_IT_BINDS_WITH', 'ANOTHER VARIABLE_IT_BINDS_WITH']\n    }\n  ```\nAlternativelly, pick one medicine :\n  - define at least one module that has this dependency + variable binding (currently using AMD only) and uRequire will find it!\n  - use an `rjs.shim`, and uRequire will pick it from there (@todo: NOT IMPLEMENTED YET!)\n  - RTFM & let us know if still no remedy!");
        return this.build.done(false);
      } else {
        almondTemplates = new AlmondOptimizationTemplate({
          globalDepsVars: globalDepsVars,
          noWeb: this.dependencies.noWeb,
          main: this.main
        });
        _ref2 = almondTemplates.dependencyFiles;
        for (fileName in _ref2) {
          genCode = _ref2[fileName];
          Build.outputToFile("" + this.build.outputPath + "/" + fileName + ".js", genCode);
        }
        this.copyAlmondJs();
        this.copyWebMapDeps();
        try {
          _fs.unlinkSync(this.build.combinedFile);
        } catch (_error) {
          err = _error;
        }
        rjsConfig = {
          paths: _.extend(almondTemplates.paths, this.getRequireJSConfig().paths),
          wrap: almondTemplates.wrap,
          baseUrl: this.build.outputPath,
          include: [this.main],
          deps: this.dependencies.noWeb,
          out: this.build.combinedFile,
          name: 'almond',
          optimize: "none"
        };
        if (optimize = this.build.optimize) {
          optimizers = ['uglify2', 'uglify'];
          if (optimize === true) {
            optimizeMethod = optimizers[0];
          } else {
            if (_.isObject(optimize)) {
              optimizeMethod = _.find(optimizers, function(v) {
                return __indexOf.call(_.keys(optimize), v) >= 0;
              });
            } else {
              if (_.isString(optimize)) {
                optimizeMethod = _.find(optimizers, function(v) {
                  return v === optimize;
                });
              }
            }
          }
          if (optimizeMethod) {
            rjsConfig.optimize = optimizeMethod;
            rjsConfig[optimizeMethod] = optimize[optimizeMethod];
          } else {
            l.err("Quitting - unknown optimize method:", optimize);
            build.done(false);
          }
        }
        if (l.deb(90)) {
          rjsConfig.logLevel = 0;
        }
        l.verbose("Optimize with r.js with uRequire's 'build.js' = \n", _.omit(rjsConfig, ['wrap']));
        this.requirejs.optimize(_.clone(rjsConfig), function(buildResponse) {
          return l.verbose('r.js buildResponse = ', buildResponse);
        });
        return setTimeout((function() {
          l.debug(60, 'Checking r.js output file...');
          if (_fs.existsSync(build.combinedFile)) {
            l.log("Combined file '" + build.combinedFile + "' written successfully.");
            globalDepsVars = _this.getDepsVars({
              depType: 'global'
            });
            if (!_.isEmpty(globalDepsVars)) {
              l.log("Global bindinds: make sure the following global dependencies:\n", globalDepsVars, "\n\nare available when combined script '" + build.combinedFile + "' is running on:\n\na) nodejs: they should exist as a local `nodes_modules`.\n\nb) Web/AMD: they should be declared as `rjs.paths` (or `rjs.baseUrl`)\n\nc) Web/Script: the binded variables (eg '_' or '$')\n   must be a globally loaded (i.e `window.$`) BEFORE loading '" + build.combinedFile + "'");
            }
            if (!l.deb(50)) {
              l.debug(40, "Deleting temporary directory '" + build.outputPath + "'.");
              _wrench.rmdirSyncRecursive(build.outputPath);
            } else {
              l.debug("NOT Deleting temporary directory '" + build.outputPath + "', due to debugLevel >= 50.");
            }
            return build.done(true);
          } else {
            l.err("Combined file '" + build.combinedFile + "' NOT written.\"\n\n  Some remedy:\n\n   a) Is your *bundle.main = '" + _this.main + "'* or *bundle.bundleName = '" + _this.bundleName + "'* properly defined ?\n      - 'main' should refer to your 'entry' module, that requires all other modules - if not defined, it defaults to 'bundleName'.\n      - 'bundleName' is what 'main' defaults to, if its a module.\n\n   b) Perhaps you have a missing dependcency ?\n      r.js doesn't like this at all, but it wont tell you unless logLevel is set to error/trace, which then halts execution.\n\n   c) Re-run uRequire with debugLevel >=90, to enable r.js's logLevel:0 (trace).\n      *Note this prevents uRequire from finishing properly / printing this message!*\n\n   Note that you can check the AMD-ish files used in temporary directory '" + build.outputPath + "'.\n\n   More remedy on the way... till then, you can try running r.js optimizer your self, based on the following build.js: \u001b[0m\n", rjsConfig);
            return build.done(false);
          }
        }), 100);
      }
    }
  };

  /*
  Gets dependencies & the variables (they bind with), througout this bundle.
  
  The information is gathered from all modules and joined together.
  
  Also it uses bundle.dependencies.variableNames, if some dep has no corresponding vars [].
  
  @param {Object} q optional query with two optional fields : depType & depName
  
  @return {dependencies.variableNames} `dependency: ['var1', 'var2']` eg
              {
                  'underscore': '_'
                  'jquery': ["$", "jQuery"]
                  'models/PersonModel': ['persons', 'personsModel']
              }
  */


  Bundle.prototype.getDepsVars = function(q) {
    var depsVars, gatherDepsVars, uMK, uModule, vn, _ref1, _ref2,
      _this = this;

    depsVars = {};
    gatherDepsVars = function(_depsVars) {
      var dep, dv, v, vars, _results;

      _results = [];
      for (dep in _depsVars) {
        vars = _depsVars[dep];
        dv = (depsVars[dep] || (depsVars[dep] = []));
        _results.push((function() {
          var _i, _len, _results1;

          _results1 = [];
          for (_i = 0, _len = vars.length; _i < _len; _i++) {
            v = vars[_i];
            if (__indexOf.call(dv, v) < 0) {
              _results1.push(dv.push(v));
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
    _ref1 = this.uModules;
    for (uMK in _ref1) {
      uModule = _ref1[uMK];
      gatherDepsVars(uModule.getDepsVars(q));
    }
    if ((_ref2 = this.dependencies) != null ? _ref2.variableNames : void 0) {
      vn = _B.go(this.dependencies.variableNames, {
        fltr: function(v, k) {
          var _ref3;

          return (depsVars[k] !== void 0) && _.isEmpty(depsVars[k]) && !(__indexOf.call((_ref3 = _this.dependencies) != null ? _ref3.noWeb : void 0, k) >= 0);
        }
      });
      if (!_.isEmpty(vn)) {
        l.warn("\n Picked from `@dependencies.variableNames` for some deps with missing dep-variable bindings: \n", vn);
        gatherDepsVars(vn);
      }
    }
    vn = _B.go(this.dependencies._knownVariableNames, {
      fltr: function(v, k) {
        var _ref3;

        return (depsVars[k] !== void 0) && _.isEmpty(depsVars[k]) && !(__indexOf.call((_ref3 = _this.dependencies) != null ? _ref3.noWeb : void 0, k) >= 0);
      }
    });
    if (!_.isEmpty(vn)) {
      l.warn("\n Picked from `@dependencies._knownVariableNames` for some deps with missing dep-variable bindings: \n", vn);
      gatherDepsVars(vn);
    }
    return depsVars;
  };

  return Bundle;

}).call(this, BundleBase);

if (l.deb(90)) {
  YADC = require('YouAreDaChef').YouAreDaChef;
  YADC(Bundle).before(/_constructor/, function(match, bundleCfg) {
    return l.debug("Before '" + match + "' with bundleCfg = \n", _.omit(bundleCfg, []));
  }).before(/combine/, function(match) {
    return l.debug('combine: optimizing with r.js');
  });
}

module.exports = Bundle;
